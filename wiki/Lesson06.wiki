#summary Урок 6 - Тени от объектов
#labels Tutorial

= Урок 6 - Тени от объектов =

http://img705.imageshack.us/img705/8319/175010.jpg

== Введение ==

В этом уроке мы рассмотрим как добавить тени от объектов на основе теневой карты (`shadow map`). Теневая карта использует буфер глубины (`depth buffer`), для того, чтобы определить, находится ли пиксель в прямой видимости источника освещения, либо он чем-то загорожен.

Одним из полезных свойств построения теневой карты является то, что ее построение не зависит от сложности геометрии на сцене, необходимо лишь получить буфер глубины для каждого из обсчитываемых источников освещения.

== Сцена и источник освещения ==

Для получения теневой карты нам необходимо получить буфер глубины сцены относительно положения и направления источника освещения. В этом уроке мы используем направленный источник освещения, чтобы получить буфер глубины сцены для такого источника нам понадобиться построить две матрицы:
  # Матрицу вида (`view matrix`)
  # Матрицу проекции (`projection matrix`)

Как вы можете заметить, это те же самые матрицы, которые используются в камере, поэтому удобно использовать существующие функции для работы с камерой, чтобы произвести рендер сцены относительно источника освещения.

На каждый источник освещения необходим дополнительный проход рендера сцены, с использованием камеры источника освещения. В данном уроке у нас используется только один источник освещения, поэтому понадобиться только один дополнительный проход рендера.

Стоит также отметить, что для для направленного источника освещения используется не перспективная матрица проекции, а ортогональная, ее построение выглядит следующим образом:
{{{
const mat4 OrthoProjection(float left, float right,
	float bottom, float top, float zNear, float zFar)
{
	const float tx = - (right + left) / (right - left),
	            ty = - (top + bottom) / (top - bottom),
	            tz = - (zFar + zNear) / (zFar - zNear);

	return mat4(2 / (right - left), 0, 0, tx,
	            0, 2 / (top - bottom), 0, ty,
	            0, 0, -2 / (zFar - zNear), tz,
	            0, 0, 0, 1);
}
}}}

== Буфер глубины ===

Для того, чтобы получить буфер глубины, нам необходимо:
  # Создать текстуру для хранения буфера глубины
  # Создать `Framebuffer Object (FBO)` и привязать к нему текстуру
  # Настроить камеру и выполнить рендер сцены в созданный FBO

Начнем по порядку, для начала создадим текстуру для хранения буфера глубины, делается это следующим образом:
{{{
// текстура для хранения буфера глубины
GLuint depthTexture = 0;

// функция создания текстуры для хранения буфера глубины
GLuint TextureCreateDepth(GLsizei width, GLsizei height)
{
	GLuint texture;

	// запросим у OpenGL свободный индекс текстуры
	glGenTextures(1, &texture);

	// сделаем текстуру активной
	glBindTexture(GL_TEXTURE_2D, texture);

	// установим параметры фильтрации текстуры - линейная фильтрация
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// установим параметры "оборачиваниея" текстуры - отсутствие оборачивания
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	// необходимо для использования depth-текстуры как shadow map
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);

	// соаздем "пустую" текстуру под depth-данные
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

	// проверим на наличие ошибок
	OPENGL_CHECK_FOR_ERRORS();

	return texture;
}

// создадим текстуру для хранения буфера глубины
depthTexture = TextureCreateDepth(DEPTH_TEXTURE_WIDTH, DEPTH_TEXTURE_HEIGHT);
}}}

Отдельно стоит сказать про размеры текстуры для хранения буфера глубины, обычно для использования этой текстуры как теневой карты берут удвоенный размер окна, в которое происходит рендер. Но это совсем не обязательное требование, размер надо подбирать исходя из задачи, например для этого урока я выбрал размер текстуры 1024х1024.

Далее нам необходимо создать и настроить FBO, рендер сцены мы будем осуществлять с его использованием, создание FBO выглядит следующим образом:
{{{
// Framebuffer Object (FBO) для рендера в него буфера глубины
GLuint depthFBO = 0;

// создаем FBO для рендера глубины в текстуру
glGenFramebuffers(1, &depthFBO);
// делаем созданный FBO текущим
glBindFramebuffer(GL_FRAMEBUFFER, depthFBO);

// отключаем вывод цвета в текущий FBO
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);

// указываем для текущего FBO текстуру, куда следует производить рендер глубины
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthTexture, 0);

// проверим текущий FBO на корректность
GLenum fboStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
if (fboStatus != GL_FRAMEBUFFER_COMPLETE)
	LOG_ERROR("glCheckFramebufferStatus error %d\n", fboStatus);

// возвращаем FBO по-умолчанию
glBindFramebuffer(GL_FRAMEBUFFER, 0);
}}}

После создания FBO и привязки к нему текстуры мы можем выполнить рендер всей сцены с использованием этого FBO:
{{{
// установим активный FBO
glBindFramebuffer(GL_FRAMEBUFFER, depthFBO);
// размер вьюпорта совпадает с размером текстуры для хранения буфера глубины
glViewport(0, 0, DEPTH_TEXTURE_WIDTH, DEPTH_TEXTURE_HEIGHT);
// отключаем вывод цвета
glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
// включаем вывод буфера глубины
glDepthMask(GL_TRUE);
// очищаем буфер глубины перед его заполнением
glClear(GL_DEPTH_BUFFER_BIT);
// производим рендер внутренних фейсов объектов
glCullFace(GL_FRONT);
// выполним рендер сцены с использованием шейдерной программы depthProgram и камеры lightCamera
RenderScene(depthProgram, lightCamera);
}}}

Во-первых, необходимо пояснить, что при заполнении буфера глубины нет никакой необходимости обрабатывать цвет пикселя, нам необходимо узнать только его глубину по отношению к источнику освещения.

Во-вторых, рендер внутренних фейсов объектов помогает избежать некоторых артефактов при использовании теневой карты, таких как [http://en.wikipedia.org/wiki/Z-fighting z-fighting]. Однако данный способ подходит только для замкнутых выпуклых объектов, именно такие мы и используем в этом уроке.

В-третьих, рендер сцены мы производим с использованием специальной шейдерной программы, в этой программе мы можем отключить все лишние расчеты, оставив только необходимые для получения глубины.

В минимальном варианте вершинный шефдер для такой шейдерной программы выглядит следующим образом:
{{{
layout(location = VERT_POSITION) in vec3 position;

// параметры преобразований
uniform struct Transform
{
	mat4 modelViewProjection;
} transform;

void main(void)
{
	// переводим координаты вершины в однородные
	gl_Position = transform.modelViewProjection * vec4(position, 1.0);
}
}}}

Т.к. нас интересует только глубина фрагментов, а не их цвет, то фактически фрагментный шейдер может быть пустым.