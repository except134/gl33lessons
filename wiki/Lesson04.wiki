#summary Урок 4 - Свет, камера, материал! Часть 1
#labels Tutorial

= Урок 4 - Свет, камера, материал! Часть 1 =

== Введение ==

Еще одной важной темой для графических приложений и игр является освещение. Подробно останавливаться на физическом смысле и математической модели освещения я не буду, подобных статей с описаниями хватает на просторах интернета, в конце урока будут приведены ссылки на некоторые из таких статей.

В уроке будет рассмотрено создание точечного источника света с различными параметрами, который будет освещать несколько геометрических фигур на сцене с различными материалами.

Для этого урока было решено ввести небольшую математическую библиотеку для облегчения работы с матрицами и векторами. Основные понятия по матрицам были даны в предыдущем уроке, поэтому вы уже должны предоставлять какие матрицы используются, как они создаются и как передаются в шейдерную программу.

Математическая библиотека также будет дополняться по мере необходимости, так же как и исходный код очередного урока.

== Точечный источник света ==

В компьютерной графике чаще всего работают с тремя типами источников света:
  # Точечный источник света (`point light`)
  # Направленный источник света (`directional light`)
  # Прожектор (`spot light`)

Как я уже отметил выше - в этом уроке будет рассмотрен только первый тип, другие два типа будут рассмотрены в следующем уроке. К точечному источнику света, с некоторой погрешностью, можно отнести обычную электрическую лампочку.

В общем случае у точечного источника света рассматривают следующие параметры:
  * Положение в пространстве (`position`)
  * Мощность фонового освещения (`ambient`)
  * Мощность рассеянного освещения (`diffuse`)
  * Мощность отраженного освещения (`specular`)
  * Коэффициенты затухания (`attenuation`)

{{{
// Точечный источник освещения
struct PointLight
{
	vec4  position;
	vec4  ambient;
	vec4  diffuse;
	vec4  specular;
	vec3  attenuation;
};
}}}

Типы `vec3` и `vec4` взяты из математической библиотеки, это 3х и 4х компонентные вектора с типом `float`, соответственно. Над этими типами определены основные векторные операции, такие как сложение, умножение и т.п.

Используя функционал языка GLSL мы можем в шейдере объявить точно такую же структуру данных и потом из программы передать туда параметры точечного источника освещения.

В шейдере структура с параметрами точечного источника освещения будет выглядеть так:
{{{
// параметры источника освещения
uniform struct PointLight
{
	vec4  position;
	vec4  ambient;
	vec4  diffuse;
	vec4  specular;
	vec3  attenuation;
} light;
}}}

Передавать параметры источника освещения из программы в шейдер мы будем следующим образом:
{{{
void PointLightSetup(GLuint program, const PointLight &light)
{
	glUniform4fv(glGetUniformLocation(program, "light.position"), 1, light.position.v);
	glUniform4fv(glGetUniformLocation(program, "light.ambient"), 1, light.ambient.v);
	glUniform4fv(glGetUniformLocation(program, "light.diffuse"), 1, light.diffuse.v);
	glUniform4fv(glGetUniformLocation(program, "light.specular"), 1, light.specular.v);
	glUniform3fv(glGetUniformLocation(program, "light.attenuation"), 1, light.attenuation.v);
}
}}}

Обратите внимание, что доступ к элементам структуры в шейдере идет по названию конкретного экземпляра, а не по названию структуры.

== Материал объекта ==

Помимо параметров источника освещения необходимо также знать как объект будет _реагировать_ на это освещение. Объект может светится, может рассеивать свет, может отражать свет. Все это описывают параметры материала, из которого сделан объект.

Параметры материала тесно связано с параметрами света. Наиболее часто материал определяют следующими параметрами:
  * Восприятие фонового освещения (`ambient`)
  * Восприятие рассеянного освещения (`diffuse`)
  * Восприятие отраженного освещения (`specular`)
  * Самостоятельное свечение (`emission`)
  * Коэффициент блеска (`shininess`)

Дополнительно к параметрам материала будем хранить в нем текстуру объекта:
{{{
// Материал объекта
struct Material
{
	GLuint texture;
	vec4  ambient;
	vec4  diffuse;
	vec4  specular;
	vec4  emission;
	float shininess;
};
}}}

Точно также как и с точечным источником освещения мы можем создать аналогичную структуру в шейдере:
{{{
// параметры материала
uniform struct Material
{
	sampler2D texture;
	vec4  ambient;
	vec4  diffuse;
	vec4  specular;
	vec4  emission;
	float shininess;
} material;
}}}

По аналогии с передачей параметров точечного источника освещения из программы в шейдер мы можем передавать параметры материалы:
{{{
void MaterialSetup(GLuint program, const Material &material)
{
	glUniform4fv(glGetUniformLocation(program, "material.ambient"), 1, material.ambient.v);
	glUniform4fv(glGetUniformLocation(program, "material.diffuse"), 1, material.diffuse.v);
	glUniform4fv(glGetUniformLocation(program, "material.specular"), 1, material.specular.v);
	glUniform4fv(glGetUniformLocation(program, "material.emission"), 1, material.emission.v);
	glUniform1fv(glGetUniformLocation(program, "material.shininess"), 1, &material.shininess);
}
}}}

== Камера ==

Камера в графической сцене представляет собой положение наблюдателя и то, как он видит сцену вокруг себя. Положение и направление взгляда задаются матрицей вида (`ViewMatrix`), а формат отображения задается матрицей проекции (`ProjectionMatrix`).

В этом уроке используется простая камера с возможность перемещения по сцене и обзора окружающего пространства:
{{{
struct Camera
{
	vec3 position;
	vec3 rotation;

	mat4 projection;
};
}}}

В шейдере для хранения всех данных о трансформации мы будем использовать следующую структуру:
{{{
uniform struct Transform
{
	mat4 model;
	mat4 modelViewProjection;
	mat3 normal;
	vec3 viewPosition;
} transform;
}}}

Для того, чтобы передать набор матриц трансформации вершин в шейдерную программу нам необходимо помимо камеры иметь матрицу преобразования объекта `Modelmatrix`, поэтому функция установки параметров камеры в шейдерную программу выглядит следующим образом:
{{{
void CameraSetup(GLuint program, const Camera &camera, const mat4 &model)
{
	mat4 modelViewProjection = camera.projection * (GLRotation(camera.rotation)
		* GLTranslation(-camera.position)) * model;

	glUniformMatrix4fv(glGetUniformLocation(program, "transform.model"), 1, GL_TRUE, model.m);
	glUniformMatrix4fv(glGetUniformLocation(program, "transform.modelViewProjection"), 1, GL_TRUE, modelViewProjection.m);
	glUniformMatrix3fv(glGetUniformLocation(program, "transform.normal"), 1, GL_TRUE, mat3(model).m);
	glUniform3fv(glGetUniformLocation(program, "transform.viewPosition"), 1, camera.position.v);
}
}}}

Как вы можете видеть мы ввели дополнительную матрицу `normal`, она необходима для того, чтобы переводить нормали объекта из локальной системы координат объекта в мировую, это необходимо для расчета освещения.

== Расчет освещения ===

Для расчетов освещения в этом уроке используется модель освещения Фонга (Phong shading). Основной смысл модели в том, что итоговое освещение объекта складывается из трех компонентов:
  # Фоновой свет (`ambient`)
  # Рассеянный свет (`diffuse`)
  # Отраженный свет (`specular`)

Соответственно каждый из компонентов рассчитывается с учетом параметров источника освещения и материала объекта. Боле подробную информацию по этой модели освещения вы можете получить [http://compgraphics.info/3D/lighting/phong_reflection_model.php в этой заметке].

Расчет освещения может быть как повершинным (`per-vertex lighting`) так и попиксельным (`per-pixel lighting`). В данном уроке мы рассмотрим именно поиксельное освещение, оно позволяет сгладить недостаточную детализацию полигональных моделей и более точно рассчитать освещенность в каждой точке объекта. Расчет попиксельного освещения происходит в фрагментном шейдере.

Прежде чем приступать к расчету освещения необходимо рассчитать и передать некоторые параметры вершин из вершинного шейдера в фрагментный:
  * Нормаль к поверхности объекта в вершине (`normal`)
  * Направление падающего света, от вершины к источнику освещения (`light direction`)
  * Направление взгляда, от вершины к наблюдателю (`view direction`)
  * Расстояние от точечного источника освещения до вершины (`distance`)

Нормаль к поверхности объекта и направление падающего света используются для расчета рассеянного (`diffuse`) и отраженного (`specular`) света, однако для расчета отраженного света необходимо еще дополнительно знать направление взгляда наблюдателя. Расстояние от вершины до источника освещения необходимо для расчета общего коэффициента затухания (`attenuation`).

Прежде чем приступить к расчету освещения конкретной точки нам необходимо обработать вершины объекта, после чего передать обработанные данные из вершинного шейдера в фрагментный:
{{{
// координаты вершины в мировой системе координат
vec4 vertex   = transform.model * vec4(position, 1.0);
// направление от вершины на источник света в мировой системе координат
vec4 lightDir = light.position - vertex;

// текстурные координаты вершины
Vert.texcoord = texcoord;
// переведем нормаль в мировую систему координат
Vert.normal   = normalize(transform.normal * normal);
// направление на источник света
Vert.lightDir = vec3(normalize(lightDir));
// направление на наблюдателя в мировой системе координат
Vert.viewDir  = normalize(transform.viewPosition - vec3(vertex));
// расстояние от вершины до источника освещения
Vert.distance = length(lightDir);

// переведем координаты вершины из локальных в однородные
gl_Position = transform.modelViewProjection * vec4(position, 1.0);
}}}

Итоговый алгоритм расчета освещенности одного пикселя выглядит так:
{{{
// нормализуем полученные данные для коррекции интерполяции
vec3 normal   = normalize(Vert.normal);
vec3 lightDir = normalize(Vert.lightDir);
vec3 viewDir  = normalize(Vert.viewDir);

// цвет текселя
vec4 textureColor = texture(material.texture, Vert.texcoord);

// коэффициент затухания
float attenuation = 1.0 / (light.attenuation[0] +
	light.attenuation[1] * Vert.distance +
	light.attenuation[2] * Vert.distance * Vert.distance);

// свечение материала
color = material.emission;

// добавим фоновое освещение
color += textureColor * material.ambient * light.ambient * attenuation;

// добавим рассеянный свет
float NdotL = max(dot(normal, normalize(lightDir)), 0.0);
color += textureColor * material.diffuse * light.diffuse * NdotL * attenuation;

// добавим отраженный свет
float RdotV = pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), material.shininess);
color += textureColor * material.specular * light.specular * RdotV * attenuation;
}}}

== Скриншот урока ==

http://img822.imageshack.us/img822/9845/013956.jpg

== Полезные ссылки ==

  # [http://compgraphics.info/3D/lighting/phong_reflection_model.php Модель отражения Фонга]
  # [http://fly.cc.fer.hr/~unreal/theredbook/chapter06.html OpenGL Red Book Lighting]
  # [http://www.lighthouse3d.com/opengl/glsl/index.php?lights GLSL Tutorial Lighting]
  # [http://www.ozone3d.net/tutorials/glsl_lighting_phong.php Lighting with GLSL Phong model]

== Исходный код ==

Доступ к исходному коду уроку с проектом для MSVC можно получить двумя способами:
  * Используя SVN [http://code.google.com/p/gl33lessons/source/browse/#svn/branches/lesson04 lesson04]
  * Скачав архив [http://code.google.com/p/gl33lessons/downloads/detail?name=lesson04.zip lesson04.zip]