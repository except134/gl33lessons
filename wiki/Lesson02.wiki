#summary Урок 2 - Рисуем треугольник с использованием OpenGL 3.3
#labels Tutorial

= Урок 2 - Рисуем треугольник с использованием OpenGL 3.3 =

== Введение ==

Если вы уже работали с версиями OpenGL младше 3.0, то наверняка вам приходилось использовать конструкции вид `glBegin()` / `glEnd()`:
{{{
glBegin(GL_TRIANGLES);
	glColor3f(1.0f, 0.0f, 0.0f);
	glVertex3f(-1.0f, -1.0f, -2.0f);

	glColor3f(0.0f, 1.0f, 0.0f);
	glVertex3f( 0.0f,  1.0f, -2.0f);

	glColor3f(0.0f, 0.0f, 1.0f);
	glVertex3f( 1.0f, -1.0f, -2.0f);
glEnd();
}}}

Эта конструкция рисует на экране треугольник с разным цветом в вершинах. Во втором уроке речь пойдет о том, как средствами OpenGL 3.3 вывести этот же треугольник на экран. Вы увидите, какую работу OpenGL более старых версий делал за программиста, теперь вся эта работа легла целиком на наши плечи :)

== Загрузка расширений ==

Из первого урока вы узнали как создать контекст с поддержкой OpenGL 3.3, однако одного контекста мало, необходимо еще получить доступ к функционалу OpenGL 3.3 Для этого предусмотрен специальный механизм получения указателей на функции из драйвера видеокарты, который был мельком упомянут в предыдущем уроке, для Windows это функция `wglGetProcAddress`.

Стоит также оговориться почему нам необходима функция `wglGetProcAddress`, дело в том что при сборке приложения в Windows нам доступна только библиотека с поддержкой функционала OpenGL 1.1, а все функции из старших версий мы должны загружать уже в процессе работы приложения, динамически. Не во всех ОС это так, например в Linux производители драйверов для видеокарт распространяют библиотеку с поддержкой именно того функционал, который есть в драйвере, его можно подключать уже в момент сборки приложения, статически. Но даже там есть возможность загружать расширения в процессе работы приложения, сделано это для того, чтобы бинарные файлы собранные на одном компьютере могли быть запущены на другом, возможно с совершенно другим драйвером.

Кстати, называть "расширениями" функции находящиеся в ядре OpenGL 3.3 не совсем верно, это уже не расширение функционала, это стандартный набор для версии 3.3, однако по старой традиции обычно все функции которые надо грузить динамически называют "расширениями".

Динамическая загрузка функция достаточно проста, вы уже видели как используется функция `wglGetProcAddress` в прошлом уроке - надо создать контекст OpenGL нужной версии и можно приступать к загрузке функций. Для динамической загрузки функций нам понадобится файл с прототипами этих функций [http://www.opengl.org/registry/api/glext.h glext.h]. Этот свободно доступен с сайта opengl.org и с выходом новых версий стандарта OpenGL он обновляется. В архиве с исходниками к этому уроку этот файл уже есть.

Используя прототипы мы определим указатели на функции и после создания контекста с поддержкой OpenGL 3.3 загрузим их динамически. Выглядит это так:
{{{
// используя прототип из glext.h определяем указатель на функцию
PFNGLCREATEPROGRAMPROC glCreateProgram = NULL;

// после создания контекста получаем указатель на функцию
glCreateProgram = (PFNGLCREATEPROGRAMPROC)wglGetProcAddress("glCreateProgram");

// запишем в лог ошибку, если не удалось получить указатель на функцию из драйвера
if (glCreateProgram == NULL)
{
	LOG_ERROR("Loading extension 'glCreateProgram' fail (%d)\n", GetLastError());

	return false;
}
}}}

В исходниках приложенных к этому уроку процесс получения указателя и проверки на успех немного автоматизирован с использованием макроса `OPENGL_GET_PROC`:
{{{
// макрос для получения указателя на функцию и проверка его на валидность
#define OPENGL_GET_PROC(p,n) \

	n = (p)wglGetProcAddress(#n); \

	if (NULL == n) \

	{ \

		LOG_ERROR("Loading extension '%s' fail (%d)\n", #n, GetLastError()); \

		return false; \

	}

// используется макрос следующим образом
OPENGL_GET_PROC(PFNGLCREATEPROGRAMPROC, glCreateProgram);
}}}

Также существуют различные готовые библиотеки, которые позволяют еще больше автоматизировать работу с расширениями, например библиотека [http://glew.sourceforge.net/ GLEW]. Однако в наших уроках нм не понадобиться большой список расширений, поэтому будем использовать "ручной" способ загрузки, представленный выше.

== Загрузка шейдеров ==

Напоминаю, для тех кто забыл, что фиксированный конвейер обработки данных видеокартой был убран из OpenGL версии 3.0 и выше. Теперь такие данные как вершины и пиксели обрабатываются специальном пользовательской программой - шейдером, соответственно вершинным и фрагментным (пиксельным), которые вкупе представляют собой шейдерную программу.

Без использования хотя бы простейшего шейдера мы не получим никакой картинки на экране своего монитора, таким образом, вторая ступень для вывода треугольника на экран - загрузка и подготовка к работе шейдерной программы.

Для начала определимся с функционалом, который нам нужен от шейдерной программы. Необходимо вывести на экран треугольник с разноцветными вершинами, таким образом на каждую вершину нам понадобится два параметра - позиция и цвет, такие параметры в шейдере называются _атрибутами_ (attributes). Атрибуты предназначены для каждой вершины индивидуально. Помимо атрибутов в шейдере также используются _юниформы_ (uniforms), они общие для всех, обрабатываемых шейдером, вершин, либо для определенной группы вершин.

Шейдеры для OpenGL пишутся с использованием специального языка GLSL, на который имеется спецификация (доступна с сайта opengl.org). Мы будем использовать [http://www.opengl.org/registry/doc/GLSLangSpec.3.30.6.clean.pdf GLSL 3.30], эта версия GLSL вышла одновременно с выходом стандарта [http://www.opengl.org/registry/doc/glspec33.core.20100311.pdf OpenGL 3.3].

Выше было отмечено, что шейдерная программа состоит из нескольких шейдеров для разных данных, в этом уроке нам понадобиться фершинный и фрагментный шейдеры. Вот код подходящего для нашей задачи вершинного шейдера:
{{{
#version 330 core



uniform mat4 projectionMatrix;



in vec3 position;

in vec3 color;



out vec3 fragmentColor;



void main(void)

{

	gl_Position   = projectionMatrix * vec4(position, 1.0);

	fragmentColor = color;

}

}}}

Входные атрибуты обозначены как `in`, а выходные атрибуты как `out`, юниформы обозначаются как `uniform`. Выходные атрибуты предназначены для передачи данных из шейдера на следующий этап обработки данных, в нашем случае следующий этап это фрагментный шейдер:
{{{
#version 330 core



in vec3 fragmentColor;



out vec4 color;



void main(void)

{

	color = vec4(fragmentColor, 1.0);

}

}}}

Здесь имеется выходной атрибут `color`, он определяет какого цвета будет пиксель на экране. Стоит также отметить что фрагментный шейдер получает интерполированные данные из предыдущего вершинного шейдера, каким образом данные будут интерполироваться можно указать отдельно для каждого атрибута, по-умолчанию это обычная линейная интерполяция. Таким образом, в случае с атрибутом `fragmentColor`, цвет меняется "линейно" от вершины к вершине.

После того как шейдеры будут готовы их можно загрузить из программы и создать из них шейдерную программу.